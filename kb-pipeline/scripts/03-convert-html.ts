#!/usr/bin/env npx tsx
/**
 * 03-convert-html.ts
 * Convert HTML files to Markdown
 */

import { join, basename, extname } from 'path';
import { existsSync, readFileSync } from 'fs';
import { config, configLoader } from '../lib/config.js';
import { htmlConverter } from '../lib/html-converter.js';
import { 
  findFiles, writeMarkdown, writeJson, logger, 
  ensureDir, detectVersion, hasNewerVersion, Progress 
} from '../lib/utils.js';

interface ConversionResult {
  source: string;
  output: string;
  version: string;
  success: boolean;
  error?: string;
  hasNewerVersion?: string;
}

async function main() {
  logger.step('CONVERT', 'Converting HTML to Markdown...');
  
  const rawPath = configLoader.resolvePath(config.sources.docsRaw);
  const htmlPath = join(rawPath, 'html');
  const outputPath = join(configLoader.resolvePath(config.output.docs), 'converted');
  const reportsPath = configLoader.resolvePath(config.output.reports);
  
  ensureDir(outputPath);
  ensureDir(reportsPath);

  // Find HTML files
  if (!existsSync(htmlPath)) {
    logger.warn(`HTML directory not found: ${htmlPath}`);
    logger.info('No HTML files to convert. Skipping...');
    
    // Write empty report
    const report = {
      timestamp: new Date().toISOString(),
      totalFiles: 0,
      converted: 0,
      failed: 0,
      skipped: 0,
      results: [],
    };
    writeJson(join(reportsPath, 'conversion-result.json'), report);
    return;
  }

  const htmlFiles = await findFiles('**/*.html', htmlPath);
  
  if (htmlFiles.length === 0) {
    logger.warn('No HTML files found to convert');
    return;
  }

  logger.info(`Found ${htmlFiles.length} HTML files`);

  const results: ConversionResult[] = [];
  const progress = new Progress(htmlFiles.length, 'Converting');

  for (const htmlFile of htmlFiles) {
    const filename = basename(htmlFile);
    const version = detectVersion(filename);
    
    try {
      // Check for newer version
      const newerVersion = hasNewerVersion(htmlFiles, htmlFile);
      
      if (newerVersion && config.versionDetection.preferLatest) {
        results.push({
          source: htmlFile,
          output: '',
          version,
          success: true,
          hasNewerVersion: newerVersion,
        });
        progress.tick(`${filename} (skipped - newer exists)`);
        continue;
      }

      // Read and convert
      const html = readFileSync(htmlFile, 'utf-8');
      const markdown = htmlConverter.convert(html);
      
      // Generate output filename
      const outputFilename = basename(htmlFile, extname(htmlFile)) + '.md';
      const outputFile = join(outputPath, outputFilename);
      
      writeMarkdown(outputFile, markdown);
      
      results.push({
        source: htmlFile,
        output: outputFile,
        version,
        success: true,
      });
      
      progress.tick(filename);
      
    } catch (error) {
      results.push({
        source: htmlFile,
        output: '',
        version,
        success: false,
        error: String(error),
      });
      progress.tick(`${filename} (failed)`);
    }
  }

  // Generate report
  const report = {
    timestamp: new Date().toISOString(),
    totalFiles: htmlFiles.length,
    converted: results.filter(r => r.success && !r.hasNewerVersion).length,
    failed: results.filter(r => !r.success).length,
    skipped: results.filter(r => r.hasNewerVersion).length,
    results,
  };

  writeJson(join(reportsPath, 'conversion-result.json'), report);
  
  // Generate markdown report
  const mdReport = generateMarkdownReport(report);
  writeMarkdown(join(reportsPath, 'conversion-report.md'), mdReport);

  // Summary
  console.log('\n' + '='.repeat(50));
  logger.info(`Converted: ${report.converted} files`);
  logger.info(`Skipped: ${report.skipped} files (newer versions exist)`);
  if (report.failed > 0) {
    logger.warn(`Failed: ${report.failed} files`);
  }
}

function generateMarkdownReport(report: any): string {
  return `# HTML Conversion Report

> Generated: ${report.timestamp}

## Summary

| Metric | Value |
|--------|-------|
| Total Files | ${report.totalFiles} |
| Converted | ${report.converted} |
| Skipped | ${report.skipped} |
| Failed | ${report.failed} |

## Details

${report.results.map((r: ConversionResult) => {
  const status = r.hasNewerVersion 
    ? '⏭️ Skipped' 
    : r.success 
      ? '✅ Success' 
      : '❌ Failed';
  
  return `### ${basename(r.source)}

- **Status:** ${status}
- **Version:** ${r.version}
${r.hasNewerVersion ? `- **Newer version:** ${basename(r.hasNewerVersion)}` : ''}
${r.error ? `- **Error:** ${r.error}` : ''}
`;
}).join('\n')}

---
*Generated by KB Pipeline*
`;
}

main().catch(error => {
  logger.error(`Conversion failed: ${error}`);
  process.exit(1);
});
